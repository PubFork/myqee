#!/usr/bin/env php
<?php
# 将指定项目的assets目录和调用类库的的assets目录的文件进行合并，并输出保存到 wwwroot/assets/ 对应项目目录里

# 本脚本依赖 recess 和 uglifyjs 分别处理css和js
# recess   https:#github.com/twitter/recess
# uglifyjs https:#github.com/mishoo/UglifyJS
#
# 安装方法：
#
#  npm install recess -g
#  npm install uglify-js@1


# 不自动执行，这样只初始化Bootstrap和Core类，而不执行Core::run()方法
$auto_run = false;


$argv = $_SERVER['argv'];
array_shift($argv);

if (!isset($argv[0]) || !$argv[0])
{
    help();
}


function help()
{
    echo <<<EOF
使用方法: $ \x1b[36mmerge-assets\x1b[39m \x1b[33m[project]\x1b[39m [options]

OPTIONS:
  -r \x1b[32m全部重新生成\x1b[39m

EXAMPLE:
  $ \x1b[36mmerge-assets\x1b[39m \x1b[33mdefault\x1b[39m

EOF;
    exit;
}

# 调用项目
$project = $argv[0];

include (dirname(__FILE__).'/../index.php');

echo "待合并目录：\n";
foreach (Bootstrap::$include_path as $path)
{
    echo "  => ".Core::debug_path($path)."\n";
}

if (in_array('-r',$argv))
{
    $recreate = true;
}
else
{
    $recreate = false;
}

$include_path = Bootstrap::$include_path;
$include_path = array_reverse($include_path);

# 循环获取所有文件列表
$file_paths = array();

# 循环include path
foreach ($include_path as $path)
{
    $dir = $path ."assets/";

    if (is_dir($dir))
    {
        glob_files($file_paths,$dir,strlen($dir));
    }
}

echo "\n文件数:\n";

# 输出目录
$out_dir = DIR_ASSETS . $project .'/';

# 记录所有文件的修改时间
$edit_times = array();

# 输出信息
foreach (array('css'=>'css ','less'=>'less','js'=>'js  ','other'=>'其它','extends'=>'扩展','modules'=>'模块') as $type=>$name)
{
    if (isset($file_paths[$type]) && $file_paths[$type])
    {
        echo "  => 找到{$name}文件: \x1b[33m".count($file_paths[$type])."\x1b[39m\n";
    }
}


echo "\n开始合并文件:";

$done    = "[\x1b[35m未修改\x1b[39m]";
$success = "\x1b[32m✔\x1b[39m";
$error   = "\x1b[31m✕\x1b[39m";
$out_dir_path = Core::debug_path($out_dir);

# 记录需要压缩处理的文件列表
$todo_min_files = array();
foreach (array('css','less','js','other') as $type)
{
    if (!isset($file_paths[$type]) || !$file_paths[$type])
    {
        continue;
    }

    foreach ($file_paths[$type] as $tmpfile => $fullpath)
    {
        # 输出的文件名
        $out_file = $out_dir . $tmpfile;

        if (is_file($out_file))
        {
            # 已经有文件，检查下修改时间看看是否需要替换

            # 读取文件最后修改时间
            $old_out_file_filemtime = filemtime($out_file);

            $need_renew = false;

            if (false===$recreate)
            {
                if ($old_out_file_filemtime > filemtime($fullpath))
                {
                    if ($type=='css'||$type=='js')
                    {
                        # 扩展中
                        if (isset($file_paths['extends'][$tmpfile]) && $file_paths['extends'][$tmpfile])
                        {
                            if ($old_out_file_filemtime < filemtime($file_paths['extends'][$tmpfile]))
                            {
                                $need_renew = true;
                            }
                        }

                        # 模块中
                        if (isset($file_paths['modules'][$tmpfile]) && $file_paths['modules'][$tmpfile])
                        {
                            foreach ($file_paths['modules'][$tmpfile] as $tmpmfile)
                            {
                                if ($old_out_file_filemtime < filemtime($tmpmfile))
                                {
                                    $need_renew = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    $need_renew = true;
                }
            }
            else
            {
                $need_renew = true;
            }

            # 无需修改
            if (!$need_renew)
            {
                echo "\n  => {$out_dir_path}{$tmpfile} ".$done;
                continue;
            }
        }

        # 内容
        $content = file_get_contents($fullpath);
        if ($type=='css'||$type=='less'||$type=='js')
        {
            if (isset($file_paths['extends'][$tmpfile]) && $file_paths['extends'][$tmpfile])
            {
                # 读取扩展文件进行合并
                $content .= CRLF . file_get_contents($file_paths['extends'][$tmpfile]);
            }

            # JS的模块直接合并即可，CSS利用less处理@import的文件进行合并
            if ($type=='js')
            {
                if (isset($file_paths['modules'][$tmpfile]) && $file_paths['modules'][$tmpfile])foreach($file_paths['modules'][$tmpfile] as $tmpmfile)
                {
                    # 读取JS模块文件进行合并
                    $content .= CRLF.file_get_contents($tmpmfile);
                }
            }

            if (substr($out_file,-strlen($type)-5)!='.min.'.$type)
            {
                $todo_min_files[$type=='less'?'css':$type][$tmpfile] = $out_file;
            }
        }

        # 如果应该输出为文件的路径变成了文件夹，则先删除
        if (is_dir($out_file))
        {
            File::remove_dir($out_file);
        }

        # 写入文件
        $rs = File::create_file($out_file, $content);
        echo "\n  => {$out_dir_path}{$tmpfile} " . ($rs?$success:$error);

        # 对于CSS或LESS文件，如果有扩展模块，则先把扩展文件写入到文件中
        if ( ($type=='css'||$type=='less') && isset($file_paths['modules'][$tmpfile]) && $file_paths['modules'][$tmpfile])foreach ($file_paths['modules'][$tmpfile] as $filename => $tmpmfile)
        {
            $outm_file = $out_dir . $filename;
            $rs = File::create_file($outm_file, file_get_contents($tmpmfile));
            echo "\n     {$out_dir_path}{$filename} " . ($rs?$success:$error);
        }
    }
}



# 处理压缩
# ----------------------

# 读取nodejs配置
static $node_file = null;
static $node_modules_path = null;
if (null===$node_file)
{
    # 获取node的执行文件路径和node_modules的路径
    list($node_file,$node_modules_path) = get_node_set();
}


echo "\n\n准备压缩JS和CSS:\njs文件数:  \x1b[33m".count($todo_min_files['js'])."\x1b[39m\n";
# 压缩js
if (isset($todo_min_files['js']) && $todo_min_files['js'])foreach ($todo_min_files['js'] as $tmpname => $realfile)
{
    $output = '';

    $cmd = 'cd '.(escapeshellcmd($node_modules_path)).' && ' . escapeshellcmd($node_file).' '.escapeshellarg('./node_modules/uglify-js/bin/uglifyjs').' '.escapeshellarg($realfile).' -nc';

    exec($cmd,$output,$r);
    if (0===$r)
    {
        # 写入文件
        File::create_file(substr($realfile,0,-3).'.min.js',implode('',$output));
        echo "  => ".$out_dir_path.substr($tmpname,0,-3).".min.js " . ($rs?$success:$error)."\n";
    }
    else
    {
        echo "系统执行uglifyjs处理失败，请检查执行uglifyjs是否安装或模块路径是否配置正确\nuglifyjs安装方法见 https:#github.com/mishoo/UglifyJS \n执行的命令为：\n";
        echo $cmd ."\n";
        exit;
    }
}


echo "CSS文件数: \x1b[33m".count($todo_min_files['css'])."\x1b[39m\n";
# 压缩处理less和css
if (isset($todo_min_files['css']) && $todo_min_files['css'])foreach ($todo_min_files['css'] as $tmpname => $realfile)
{
    $type = substr($tmpname,strrpos($tmpname,'.')+1);
    if ($type=='less')
    {
        $n = 5;
        $gostr = '  ';
    }
    else
    {
        $n = 4;
        $gostr = '=>';
    }

    if ($type=='less')
    {
        # 处理LESS转换为CSS
        $output = '';
        $cmd = 'cd '.(escapeshellcmd($node_modules_path)).' && ' . escapeshellcmd($node_file).' '.escapeshellarg('./node_modules/recess/bin/recess').' --compile '.escapeshellarg($realfile);
        exec($cmd,$output,$r);
        if (0===$r)
        {
            # 写入文件
            File::create_file(substr($realfile,0,-$n).'.css',implode('',$output));
            echo "  => ".$out_dir_path.substr($tmpname,0,-$n).".css " . ($rs?$success:$error)."\n";
        }
        else
        {
            echo "系统执行less处理失败，请检查执行recess是否安装或模块路径是否配置正确\nrecess的安装方法见 https:#github.com/twitter/recess \n执行的命令为：\n";
            echo $cmd ."\n";
            exit;
        }
    }

    # 处理压缩
    $output = '';
    $cmd = 'cd '.(escapeshellcmd($node_modules_path)).' && ' . escapeshellcmd($node_file).' '.escapeshellarg('./node_modules/recess/bin/recess').' --compress '.escapeshellarg($realfile);
    exec($cmd,$output,$r);
    if (0===$r)
    {
        # 写入文件
        File::create_file(substr($realfile,0,-$n).'.min.css',implode('',$output));
        echo "  {$gostr} ".$out_dir_path.substr($tmpname,0,-$n).".min.css " . ($rs?$success:$error)."\n";
    }
    else
    {
        echo "系统执行less处理失败，请检查执行recess是否安装或模块路径是否配置正确\nrecess的安装方法见 https:#github.com/twitter/recess \n执行的命令为：\n";
        echo $cmd ."\n";
        exit;
    }
}

echo "\n清理Less文件";

if (isset($file_paths['less']) && $file_paths['less'])foreach($file_paths['less'] as $tmpname=>$tmpfile)
{
    File::unlink($out_dir.$tmpname);
}

if (isset($file_paths['modules']) && $file_paths['modules'])foreach($file_paths['modules'] as $tmpparenname=>$tmpfiles)
{
    $type = substr($tmpparenname,strrpos($tmpparenname,'.')+1);
    if ($type=='less')
    {
        foreach ($tmpfiles as $tmpname => $tmpfile)
        {
            File::unlink($out_dir.$tmpname);
        }
    }
}


echo "\n\n合并结束\n";


/**
 * 递归的读取目录下所有文件到$file_paths中
 */
function glob_files(&$file_paths,$dir,$dir_len)
{
    $files = glob( $dir .'*', GLOB_NOSORT );

    if ($files)foreach ($files as $file)
    {
        if ($file==='.'||$file==='..'||substr($file,0,1)==='.')continue;

        # 文件夹
        if (is_dir($file))
        {
            glob_files($file_paths,$file.'/',$dir_len);
            continue;
        }

        $file = str_replace('\\', '/', $file);
        $path_rpos = strrpos($file,'/');

        # 文件名
        $file_name = substr($file,$path_rpos+1);

        $rpos = strrpos($file_name,'.');
        if ($rpos>0)
        {
            # 后缀
            $suffix = strtolower(substr($file_name,$rpos+1));
            $file_path = substr($file,$dir_len,-strlen($file_name)).$file_name;

            if ($suffix=='css'||$suffix=='less'||$suffix=='js')
            {
                $file_name_arr = explode('.',$file_name);
                $count_file_name_arr = count($file_name_arr);

                if ($count_file_name_arr>2)
                {
                    if ('extend' == strtolower($file_name_arr[$count_file_name_arr-2]))
                    {
                        # 扩展
                        unset($file_name_arr[$count_file_name_arr-2]);
                        $parent_file_name = implode('.',$file_name_arr);
                        $parent_file_path = substr($file,$dir_len,-strlen($file_name)).$parent_file_name;

                        if ($suffix=='less')
                        {
                            $parent_file_path = substr($file_path,0,-strlen($sub)).'.css';
                        }
                        # 记录到扩展数据里
                        $file_paths['extend'][$parent_file_path] = $file;
                        continue;
                    }
                }
                else if (($rpos_m = strrpos($file_name_arr[0],'-'))>0)
                {
                    # 横线隔开的模块
                    $file_name_arr[0] = substr($file_name_arr[0],0,$rpos_m);
                    $parent_file_name = implode('.',$file_name_arr);
                    $parent_file_path = substr($file,$dir_len,-strlen($file_name)).$parent_file_name;

                    # 记录到模块数据里
                    $file_paths['modules'][$parent_file_path][$file_name] = $file;
                    continue;
                }

                $file_paths[$suffix][$file_path] = $file;
            }
            else
            {
                $file_paths['other'][$file_path] = $file;
            }
        }
    }
}

/**
 * 获取node的设置
 *
 * @return array(exe_file_path,modules_path)
 */
function get_node_set()
{
    # nodejs 执行程序目录
    $node_config = Core::config('core.nodejs');
    if (IS_WIN)
    {
        if (isset($node_config['exec']['window']))
        {
            $node_file = $node_config['exec']['window'];
        }
    }
    else
    {
        if (isset($node_config['exec']['other']))
        {
            $node_file = $node_config['exec']['other'];
        }
    }
    if (!$node_file)
    {
        $node_file = IS_WIN ? 'c:\\Program Files\\nodejs\\node.exe' : '/usr/local/bin/node';
    }

    if (IS_WIN)
    {
        if (isset($node_config['modules_path']['window']))
        {
            $node_modules_path = $node_config['modules_path']['window'];
        }
    }
    else
    {
        if (isset($node_config['modules_path']['other']))
        {
            $node_modules_path = $node_config['modules_path']['other'];
        }
    }

    # 获取node_modules目录
    if (!$node_modules_path)
    {
        $node_modules_path = IS_WIN ? 'c:\\Program Files\\nodejs\\node_modules\\' : '/usr/local/lib/node_modules/';
    }
    $node_modules_path = explode('/', str_replace('\\', '/', rtrim($node_modules_path,'/\\')));
    $i = count($node_modules_path)-1;
    if ($node_modules_path[$i]=='node_modules')
    {
        # 将node_modules移除
        unset($node_modules_path[$i]);
    }

    # 得到node_modules的父目录
    $node_modules_path = implode(DS, $node_modules_path) . DS;

    if (!is_dir($node_modules_path))
    {
        if (is_dir(DIR_SYSTEM.'node_modules'.DS))
        {
            $node_modules_path = DIR_SYSTEM . 'node_modules' . DS;
        }
        else
        {
            throw new Exception('node_modules目录不存在，请修改config'.EXT.'中$config[\'nodejs\'][\'modules_path\']中配置');
        }
    }

    return array($node_file,$node_modules_path);
}
